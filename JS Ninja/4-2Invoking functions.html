<!DOCTYPE html>
<html>
<head>
	<title></title>
	<style type="text/css">
		#first {
			color: #42e042;
		}

		#second {
			color: red;
		}
	</style>
</head>
<body>
	<ul id="results"></ul>
	<ul id="first"></ul>

	<!-- <ul id="second">ddddddddddddddd</ul> -->

	<script type="text/javascript">

	function assert(value, desc) {
		var li = document.createElement("li");
		li.className = value ? "pass" : "fail";
		li.appendChild(document.createTextNode(desc));
		document.getElementById("results").appendChild(li);
	}

	function ninja() {
		return this;
	}

	function samurai() {
		"use strict"
		return this;
	}

	function whatsMyContext () {
		return this;
	}

	assert(ninja() == window, "In a 'nonstrict' ninja function 'this' is window" );
	assert(samurai() == undefined, "In a 'strict' samurai function 'this' is undefined");

	var getMyThis = whatsMyContext;  //不会创建函数的第二个instance， 只会创建一个函数的reference。 因为函数是（first-class）object嘛

	var ninja1 = {
		getMyThis: whatsMyContext // getMyThis 是 ninja1中的method, whatsMyContext仍然是一个independent function
	}

	assert(ninja1.getMyThis() === ninja1, "Working with 1st ninja");

	var ninja2 = {
		getMyThis: whatsMyContext
	}

	assert(ninja2.getMyThis() === ninja2, "Working with 2st ninja");

	new whatsMyContext(); // invoke whatsMyContext as a constructor


	</script>
</body>
</html>